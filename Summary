Конспект по XPath

Примеры будут приводиться на сайте https://pikabu.ru/best

1. Абсолютный XPath - ведется путь от начала и до нужного элемента, последовательно по всем веткам. (Не используется, так как, в случае, 
если верстальщик внесет изменения, то путь изменится)

/html/body/div/header/div[2]/div/div[2]/div[2]/div/div[3]/a

2. XPath нулевого уровня, поиск только по первому тегу

//div[3]/a
//div[3]/*

// - означает поиск по всему телу html
* - означает любой элемент в поиске

3. Поиск с использованием тегов и классов

//div[@class="header-menu__item"]/a
//div[@class="header-menu__item"][@data-feed-key="new"]/a

4. Поиск с использованием классов по ключевым словам в них, то есть вписываем в поиска значение класса не полностью

//div[contains(@class, 'item')][@data-feed-key='new']/a
//a[contains(@class, 'menu')][contains(@href, '/liked')]

тут получается, что полное наименование класса div[@class="header-menu-item"]
мы заменили на div[contains(@class, 'item')]
contains - означает “содержит”

хорошо подходит для поиска по уникальным значениям класса, так как достаточно выполнить поиск по всему документу и одним запросом найти нужный элемент

5. Поиск по тексту в строке

Если осуществлять поиск по слову целиком, то синтаксис будет такой

//a[text()='Свежее']

Обязательно после слова text необходимо ставить () скобки, иначе поиск не будет работать. 

Искать можно не по слову целиком, а по части слова, но в таком случае нужно добавлять [contains(text(), 'Све')], например

//a[contains(text(), 'Све')]
Функция normalize-space убирает лишние пробелы в тексте при поиске, то есть нормализует текст, к примеру

Есть текст Пикабу_в_Telegram_
Пробелы помечены нижним подчеркиванием для удобства
В конце текста есть лишний пробел, пишем в поиск

//div[normalize-space()='Пикабу в Telegram']

В итоге в запросе нет лишнего пробела, но отрабатывает функция normalize-space и находит нужный элемент

6. Переход в дочерние и родительские ветки

Чтобы перейти в дочерний класс, ставится знак / и дальше уточнение

Чтобы перейти в родительский класс, то пишется функция /parent::class либо ставится две точки /.., например

//a[contains(text(), 'Све')]/parent::div
//a[contains(text(), 'Све')]/parent::*
//a[contains(text(), 'Све')]/..
//a[contains(text(), 'Све')]/../..

Чтобы указать следующий элемент используется функция /following-sibling::

//a[contains(@class, 'menu')][contains(@href, '/liked')]/following-sibling::*


Чтобы указать предыдущий элемент используется функция /preceding-sibling::

//a[contains(@class, 'menu')][contains(@href, '/liked')]/preceding-sibling::*
